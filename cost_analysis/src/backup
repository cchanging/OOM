while (!worklist.empty()) {
		const ICFGNode* i_node = worklist.pop();
		const ICFGNode* depend_node = avfg->cfg_depend[i_node];
		std::set<const ICFGNode*>& outSet_ref = nodeOut[i_node];
		if(avfg->cfg_expr.find(depend_node) != avfg->cfg_expr.end()){
			exit_expr = parseBinaryOp(exit_expr, avfg->cfg_expr[depend_node], '#');
		}
		for (auto iter : outSet_ref) {
			const ICFGNode* succ_node = avfg->cfg_depend[iter];
			if(avfg->cfg_depend[succ_node] == i_node)
				continue;
			std::set<const ICFGNode*>& inSet_ref = nodeIn[succ_node];
			inSet_ref.erase(i_node);
			
			// if(avfg->cfg_expr.find(depend_node) != avfg->cfg_expr.end()){
			// 	if(avfg->cfg_expr.find(succ_node) == avfg->cfg_expr.end()){
			// 		if(inSet_ref.size() == 0){
			// 			avfg->cfg_depend[succ_node] = depend_node;
			// 		}
			// 		else{ //PHINode
			// 			std::set<const ICFGNode*> depend_nodes;

			// 			std::vector<std::shared_ptr<ExprVFG>> exprs;
			// 			exprs.push_back(avfg->cfg_expr[depend_node]);
			// 			std::shared_ptr<std::vector<std::shared_ptr<ExprVFG>>> phi_exprs = make_shared<std::vector<std::shared_ptr<ExprVFG>>>(exprs);
			// 			avfg->cfg_expr[succ_node] = std::make_shared<CFG_PHIVFG>(std::move(phi_exprs));
			// 		}
			// 	}
			// 	else{
			// 		auto expr_temp = avfg->cfg_expr[succ_node];
			// 		if(expr_temp->getKind() == expr_cfg_phi){
			// 			std::shared_ptr<CFG_PHIVFG> cfg_phi = std::static_pointer_cast<CFG_PHIVFG>(expr_temp);
			// 			cfg_phi->add_expr(avfg->cfg_expr[depend_node]);
			// 		}
			// 		else{
			// 			avfg->cfg_expr[succ_node] = parseBinaryOp(avfg->cfg_expr[succ_node], avfg->cfg_expr[depend_node], '#');
			// 		}
			// 	}
			// }
			if(visited.find(succ_node) == visited.end() && inSet_ref.size() == 0){
				worklist.push(succ_node);
				visited.insert(succ_node);
			}
		}
	}
	// exit_node = avfg->cfg_depend[exit_node];
	// if(avfg->cfg_expr.find(exit_node) == avfg->cfg_expr.end()){
	// 	return std::make_shared<ConstantVFG>(0);
	// }
	// else{
	// 	return avfg->cfg_expr[exit_node];
	// }